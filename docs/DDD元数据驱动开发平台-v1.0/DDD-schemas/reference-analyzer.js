/**
 * DDDÂÖÉÊï∞ÊçÆÈ©±Âä®ÂºÄÂèëÂπ≥Âè∞ - ÂºïÁî®ÂÖ≥Á≥ªÂàÜÊûêÊúçÂä°
 * 
 * Ëá™Âä®ÂèëÁé∞ÂíåÁª¥Êä§Schema‰πãÈó¥ÁöÑÂºïÁî®ÂÖ≥Á≥ª
 * Êèê‰æõ‰ΩøÁî®Áä∂ÊÄÅÂàÜÊûêÂíåÈóÆÈ¢òÂèëÁé∞ÂäüËÉΩ
 */

class ReferenceAnalyzer {
  constructor() {
    this.referenceMap = new Map();
    this.unusedElements = new Map();
    this.orphanedReferences = new Map();
  }

  /**
   * ÂàÜÊûêÊâÄÊúâSchemaÁöÑÂºïÁî®ÂÖ≥Á≥ª
   */
  async analyzeReferences(schemas) {
    console.log('üîç ÂºÄÂßãÂàÜÊûêÂºïÁî®ÂÖ≥Á≥ª...');
    
    // Ê∏ÖÁ©∫‰πãÂâçÁöÑÁªìÊûú
    this.referenceMap.clear();
    this.unusedElements.clear();
    this.orphanedReferences.clear();

    // ÂàÜÊûêÊØè‰∏™SchemaÁöÑÂºïÁî®
    for (const [schemaName, schema] of schemas) {
      await this.analyzeSchemaReferences(schemaName, schema, schemas);
    }

    // ÁîüÊàê‰ΩøÁî®Áä∂ÊÄÅÊä•Âëä
    const report = this.generateUsageReport();
    
    console.log('‚úÖ ÂºïÁî®ÂÖ≥Á≥ªÂàÜÊûêÂÆåÊàê');
    return report;
  }

  /**
   * ÂàÜÊûêÂçï‰∏™SchemaÁöÑÂºïÁî®ÂÖ≥Á≥ª
   */
  async analyzeSchemaReferences(schemaName, schema, allSchemas) {
    const references = {
      schema: schemaName,
      references: [],
      referencedBy: []
    };

    // ÂàÜÊûêÂΩìÂâçSchemaÂºïÁî®‰∫ÜÂì™‰∫õÂÖ∂‰ªñSchemaÁöÑÂÖÉÁ¥†
    const outgoingRefs = this.findOutgoingReferences(schema, schemaName);
    references.references = outgoingRefs;

    // ÂàÜÊûêÂΩìÂâçSchemaË¢´Âì™‰∫õÂÖ∂‰ªñSchemaÂºïÁî®
    const incomingRefs = this.findIncomingReferences(schema, schemaName, allSchemas);
    references.referencedBy = incomingRefs;

    this.referenceMap.set(schemaName, references);

    // Êõ¥Êñ∞Ë¢´ÂºïÁî®SchemaÁöÑ‰ΩøÁî®Áä∂ÊÄÅ
    await this.updateUsageStatus(schemaName, references, allSchemas);
  }

  /**
   * Êü•ÊâæÂΩìÂâçSchemaÂºïÁî®ÁöÑÂÖ∂‰ªñSchemaÂÖÉÁ¥†
   */
  findOutgoingReferences(schema, currentSchemaName) {
    const references = [];
    
    // Ê†πÊçÆSchemaÁ±ªÂûãÊü•ÊâæÁâπÂÆöÂºïÁî®
    switch (currentSchemaName) {
      case 'ubiquitous-language.schema.json':
        // Áªü‰∏ÄËØ≠Ë®Ä‰∏çÂºïÁî®ÂÖ∂‰ªñSchema
        break;
        
      case 'strategic-design.schema.json':
        // ÊàòÁï•ËÆæËÆ°ÂºïÁî®Áªü‰∏ÄËØ≠Ë®ÄÁöÑÊúØËØ≠
        if (schema.boundedContexts) {
          schema.boundedContexts.forEach(context => {
            if (context.ubiquitousLanguage) {
              context.ubiquitousLanguage.forEach(termId => {
                references.push({
                  type: 'TERM_REFERENCE',
                  source: `${currentSchemaName}:${context.id}`,
                  target: `ubiquitous-language.schema.json:${termId}`,
                  description: `ÈôêÁïå‰∏ä‰∏ãÊñá "${context.name}" ÂºïÁî®ÊúØËØ≠ "${termId}"`
                });
              });
            }
          });
        }
        break;
        
      case 'tactical-design.schema.json':
        // ÊàòÊúØËÆæËÆ°ÂºïÁî®Áªü‰∏ÄËØ≠Ë®ÄÁöÑÊúØËØ≠ÂíåÂ±ûÊÄßÔºå‰ª•ÂèäÊàòÁï•ËÆæËÆ°ÁöÑÈôêÁïå‰∏ä‰∏ãÊñá
        if (schema.boundedContextId) {
          references.push({
            type: 'BOUNDED_CONTEXT_REFERENCE',
            source: currentSchemaName,
            target: `strategic-design.schema.json:${schema.boundedContextId}`,
            description: `ÊàòÊúØËÆæËÆ°ÂºïÁî®ÈôêÁïå‰∏ä‰∏ãÊñá "${schema.boundedContextId}"`
          });
        }
        
        if (schema.aggregates) {
          schema.aggregates.forEach(aggregate => {
            if (aggregate.termId) {
              references.push({
                type: 'TERM_REFERENCE',
                source: `${currentSchemaName}:${aggregate.id}`,
                target: `ubiquitous-language.schema.json:${aggregate.termId}`,
                description: `ËÅöÂêà "${aggregate.name}" ÂºïÁî®ÊúØËØ≠ "${aggregate.termId}"`
              });
            }
          });
        }
        
        if (schema.entities) {
          schema.entities.forEach(entity => {
            if (entity.termId) {
              references.push({
                type: 'TERM_REFERENCE',
                source: `${currentSchemaName}:${entity.id}`,
                target: `ubiquitous-language.schema.json:${entity.termId}`,
                description: `ÂÆû‰Ωì "${entity.name}" ÂºïÁî®ÊúØËØ≠ "${entity.termId}"`
              });
            }
            
            if (entity.attributes) {
              entity.attributes.forEach(attr => {
                if (attr.businessAttributeId) {
                  references.push({
                    type: 'BUSINESS_ATTRIBUTE_REFERENCE',
                    source: `${currentSchemaName}:${entity.id}:${attr.id}`,
                    target: `ubiquitous-language.schema.json:${attr.businessAttributeId}`,
                    description: `ÂÆû‰Ωì "${entity.name}" ÁöÑÂ±ûÊÄß "${attr.name}" ÂºïÁî®‰∏öÂä°Â±ûÊÄß "${attr.businessAttributeId}"`
                  });
                }
              });
            }
          });
        }
        break;
        
      case 'data-transfer-objects.schema.json':
        // DTOÁÆ°ÁêÜÂºïÁî®Áªü‰∏ÄËØ≠Ë®ÄÁöÑÊúØËØ≠ÂíåÂ±ûÊÄßÔºå‰ª•ÂèäÊàòÁï•ËÆæËÆ°ÁöÑÈôêÁïå‰∏ä‰∏ãÊñá
        if (schema.boundedContextId) {
          references.push({
            type: 'BOUNDED_CONTEXT_REFERENCE',
            source: currentSchemaName,
            target: `strategic-design.schema.json:${schema.boundedContextId}`,
            description: `DTOÁÆ°ÁêÜÂºïÁî®ÈôêÁïå‰∏ä‰∏ãÊñá "${schema.boundedContextId}"`
          });
        }
        
        if (schema.dataTransferObjects) {
          schema.dataTransferObjects.forEach(dto => {
            if (dto.termReferences) {
              dto.termReferences.forEach(termId => {
                references.push({
                  type: 'TERM_REFERENCE',
                  source: `${currentSchemaName}:${dto.id}`,
                  target: `ubiquitous-language.schema.json:${termId}`,
                  description: `DTO "${dto.name}" ÂºïÁî®ÊúØËØ≠ "${termId}"`
                });
              });
            }
            
            if (dto.attributes) {
              dto.attributes.forEach(attr => {
                if (attr.businessAttributeId) {
                  references.push({
                    type: 'BUSINESS_ATTRIBUTE_REFERENCE',
                    source: `${currentSchemaName}:${dto.id}:${attr.id}`,
                    target: `ubiquitous-language.schema.json:${attr.businessAttributeId}`,
                    description: `DTO "${dto.name}" ÁöÑÂ±ûÊÄß "${attr.name}" ÂºïÁî®‰∏öÂä°Â±ûÊÄß "${attr.businessAttributeId}"`
                  });
                }
              });
            }
          });
        }
        break;
        
      case 'implementation-mapping.schema.json':
        // ÂÆûÁé∞Êò†Â∞ÑÂºïÁî®Â§ö‰∏™Schema
        if (schema.domainId) {
          references.push({
            type: 'DOMAIN_REFERENCE',
            source: currentSchemaName,
            target: `strategic-design.schema.json:${schema.domainId}`,
            description: `ÂÆûÁé∞Êò†Â∞ÑÂºïÁî®È¢ÜÂüü "${schema.domainId}"`
          });
        }
        
        if (schema.boundedContextId) {
          references.push({
            type: 'BOUNDED_CONTEXT_REFERENCE',
            source: currentSchemaName,
            target: `strategic-design.schema.json:${schema.boundedContextId}`,
            description: `ÂÆûÁé∞Êò†Â∞ÑÂºïÁî®ÈôêÁïå‰∏ä‰∏ãÊñá "${schema.boundedContextId}"`
          });
        }
        
        if (schema.dtoMappings) {
          schema.dtoMappings.forEach(mapping => {
            if (mapping.sourceDtoId) {
              references.push({
                type: 'DTO_REFERENCE',
                source: `${currentSchemaName}:${mapping.id}`,
                target: `data-transfer-objects.schema.json:${mapping.sourceDtoId}`,
                description: `DTOÊò†Â∞Ñ "${mapping.id}" ÂºïÁî®Ê∫êDTO "${mapping.sourceDtoId}"`
              });
            }
            if (mapping.targetDtoId) {
              references.push({
                type: 'DTO_REFERENCE',
                source: `${currentSchemaName}:${mapping.id}`,
                target: `data-transfer-objects.schema.json:${mapping.targetDtoId}`,
                description: `DTOÊò†Â∞Ñ "${mapping.id}" ÂºïÁî®ÁõÆÊ†áDTO "${mapping.targetDtoId}"`
              });
            }
          });
        }
        
        if (schema.persistenceMappings) {
          schema.persistenceMappings.forEach(mapping => {
            if (mapping.entityId) {
              references.push({
                type: 'ENTITY_REFERENCE',
                source: `${currentSchemaName}:${mapping.id}`,
                target: `tactical-design.schema.json:${mapping.entityId}`,
                description: `ÊåÅ‰πÖÂåñÊò†Â∞Ñ "${mapping.id}" ÂºïÁî®ÂÆû‰Ωì "${mapping.entityId}"`
              });
            }
          });
        }
        break;
        
      case 'screen-definition.schema.json':
        // Â±èÂπïÂÆö‰πâÂºïÁî®Â§ö‰∏™Schema
        if (schema.domainId) {
          references.push({
            type: 'DOMAIN_REFERENCE',
            source: currentSchemaName,
            target: `strategic-design.schema.json:${schema.domainId}`,
            description: `Â±èÂπïÂÆö‰πâÂºïÁî®È¢ÜÂüü "${schema.domainId}"`
          });
        }
        
        if (schema.boundedContextId) {
          references.push({
            type: 'BOUNDED_CONTEXT_REFERENCE',
            source: currentSchemaName,
            target: `strategic-design.schema.json:${schema.boundedContextId}`,
            description: `Â±èÂπïÂÆö‰πâÂºïÁî®ÈôêÁïå‰∏ä‰∏ãÊñá "${schema.boundedContextId}"`
          });
        }
        
        if (schema.screens) {
          schema.screens.forEach(screen => {
            if (screen.dtoMappings) {
              screen.dtoMappings.forEach(mapping => {
                if (mapping.dtoId) {
                  references.push({
                    type: 'DTO_REFERENCE',
                    source: `${currentSchemaName}:${screen.id}:${mapping.id}`,
                    target: `data-transfer-objects.schema.json:${mapping.dtoId}`,
                    description: `Â±èÂπï "${screen.name}" ÁöÑDTOÊò†Â∞ÑÂºïÁî®DTO "${mapping.dtoId}"`
                  });
                }
              });
            }
          });
        }
        
        if (schema.endpointMappings) {
          schema.endpointMappings.forEach(mapping => {
            if (mapping.endpointId) {
              references.push({
                type: 'ENDPOINT_REFERENCE',
                source: `${currentSchemaName}:${mapping.id}`,
                target: `implementation-mapping.schema.json:${mapping.endpointId}`,
                description: `Á´ØÁÇπÊò†Â∞Ñ "${mapping.id}" ÂºïÁî®Á´ØÁÇπ "${mapping.endpointId}"`
              });
            }
          });
        }
        break;
        
      case 'amis-screen-definition.schema.json':
        // amisÂ±èÂπïÂÆö‰πâÂºïÁî®Â§ö‰∏™Schema
        if (schema.domainId) {
          references.push({
            type: 'DOMAIN_REFERENCE',
            source: currentSchemaName,
            target: `strategic-design.schema.json:${schema.domainId}`,
            description: `amisÂ±èÂπïÂÆö‰πâÂºïÁî®È¢ÜÂüü "${schema.domainId}"`
          });
        }
        
        if (schema.boundedContextId) {
          references.push({
            type: 'BOUNDED_CONTEXT_REFERENCE',
            source: currentSchemaName,
            target: `strategic-design.schema.json:${schema.boundedContextId}`,
            description: `amisÂ±èÂπïÂÆö‰πâÂºïÁî®ÈôêÁïå‰∏ä‰∏ãÊñá "${schema.boundedContextId}"`
          });
        }
        
        if (schema.screens) {
          schema.screens.forEach(screen => {
            if (screen.modelBindings) {
              screen.modelBindings.forEach(binding => {
                // ËøôÈáåÂèØ‰ª•Ê†πÊçÆbindingÁöÑÁ±ªÂûãÂºïÁî®‰∏çÂêåÁöÑSchema
                if (binding.entityId) {
                  references.push({
                    type: 'ENTITY_REFERENCE',
                    source: `${currentSchemaName}:${screen.id}:${binding.id}`,
                    target: `tactical-design.schema.json:${binding.entityId}`,
                    description: `amisÂ±èÂπï "${screen.name}" ÁöÑÊ®°ÂûãÁªëÂÆöÂºïÁî®ÂÆû‰Ωì "${binding.entityId}"`
                  });
                }
              });
            }
          });
        }
        break;
    }

    return references;
  }

  /**
   * Êü•ÊâæÂΩìÂâçSchemaË¢´Âì™‰∫õÂÖ∂‰ªñSchemaÂºïÁî®
   */
  findIncomingReferences(schema, currentSchemaName, allSchemas) {
    const incomingRefs = [];
    
    for (const [otherSchemaName, otherSchema] of allSchemas) {
      if (otherSchemaName === currentSchemaName) continue;
      
      const outgoingRefs = this.findOutgoingReferences(otherSchema, otherSchemaName);
      const relevantRefs = outgoingRefs.filter(ref => 
        ref.target.startsWith(`${currentSchemaName}:`)
      );
      
      incomingRefs.push(...relevantRefs);
    }

    return incomingRefs;
  }

  /**
   * Êõ¥Êñ∞‰ΩøÁî®Áä∂ÊÄÅ
   */
  async updateUsageStatus(schemaName, references, allSchemas) {
    const schema = allSchemas.get(schemaName);
    if (!schema) return;

    // Êõ¥Êñ∞usageStatus
    if (!schema.usageStatus) {
      schema.usageStatus = {};
    }

    // Ê†πÊçÆË¢´ÂºïÁî®ÊÉÖÂÜµÊõ¥Êñ∞Áä∂ÊÄÅ
    const referencedBy = references.referencedBy;
    
    schema.usageStatus.isReferencedByStrategic = referencedBy.some(ref => 
      ref.source.startsWith('strategic-design.schema.json:')
    );
    
    schema.usageStatus.isReferencedByTactical = referencedBy.some(ref => 
      ref.source.startsWith('tactical-design.schema.json:')
    );
    
    schema.usageStatus.isReferencedByDto = referencedBy.some(ref => 
      ref.source.startsWith('data-transfer-objects.schema.json:')
    );
    
    schema.usageStatus.isReferencedByImplementation = referencedBy.some(ref => 
      ref.source.startsWith('implementation-mapping.schema.json:')
    );
    
    schema.usageStatus.isReferencedByScreen = referencedBy.some(ref => 
      ref.source.startsWith('screen-definition.schema.json:') ||
      ref.source.startsWith('amis-screen-definition.schema.json:')
    );

    if (referencedBy.length > 0) {
      schema.usageStatus.lastReferencedAt = new Date().toISOString();
    }
  }

  /**
   * ÂèëÁé∞Êú™‰ΩøÁî®ÁöÑÂÖÉÁ¥†
   */
  findUnusedElements(schemas) {
    console.log('üîç ÂèëÁé∞Êú™‰ΩøÁî®ÁöÑÂÖÉÁ¥†...');
    
    for (const [schemaName, schema] of schemas) {
      const unused = [];
      
      switch (schemaName) {
        case 'ubiquitous-language.schema.json':
          if (schema.businessTerms) {
            schema.businessTerms.forEach(term => {
              if (!term.usageStatus?.isReferencedByStrategic && 
                  !term.usageStatus?.isReferencedByTactical && 
                  !term.usageStatus?.isReferencedByDto) {
                unused.push({
                  type: 'BUSINESS_TERM',
                  id: term.id,
                  name: term.name,
                  description: `ÊúØËØ≠ "${term.name}" Êú™Ë¢´‰ªª‰ΩïËÆæËÆ°Èò∂ÊÆµÂºïÁî®`
                });
              }
            });
          }
          
          if (schema.businessAttributes) {
            schema.businessAttributes.forEach(attr => {
              if (!attr.usageStatus?.isReferencedByTactical && 
                  !attr.usageStatus?.isReferencedByDto) {
                unused.push({
                  type: 'BUSINESS_ATTRIBUTE',
                  id: attr.id,
                  name: attr.name,
                  description: `‰∏öÂä°Â±ûÊÄß "${attr.name}" Êú™Ë¢´‰ªª‰ΩïËÆæËÆ°Èò∂ÊÆµÂºïÁî®`
                });
              }
            });
          }
          break;
          
        case 'strategic-design.schema.json':
          if (schema.boundedContexts) {
            schema.boundedContexts.forEach(context => {
              if (!context.usageStatus?.isReferencedByTactical && 
                  !context.usageStatus?.isReferencedByDto && 
                  !context.usageStatus?.isReferencedByImplementation && 
                  !context.usageStatus?.isReferencedByScreen) {
                unused.push({
                  type: 'BOUNDED_CONTEXT',
                  id: context.id,
                  name: context.name,
                  description: `ÈôêÁïå‰∏ä‰∏ãÊñá "${context.name}" Êú™Ë¢´‰ªª‰ΩïËÆæËÆ°Èò∂ÊÆµÂºïÁî®`
                });
              }
            });
          }
          break;
          
        case 'tactical-design.schema.json':
          if (schema.entities) {
            schema.entities.forEach(entity => {
              if (!entity.usageStatus?.isReferencedByImplementation) {
                unused.push({
                  type: 'ENTITY',
                  id: entity.id,
                  name: entity.name,
                  description: `ÂÆû‰Ωì "${entity.name}" Êú™Ë¢´ÂÆûÁé∞Êò†Â∞ÑÂºïÁî®`
                });
              }
            });
          }
          break;
          
        case 'data-transfer-objects.schema.json':
          if (schema.dataTransferObjects) {
            schema.dataTransferObjects.forEach(dto => {
              if (!dto.usageStatus?.isReferencedByImplementation && 
                  !dto.usageStatus?.isReferencedByScreen) {
                unused.push({
                  type: 'DTO',
                  id: dto.id,
                  name: dto.name,
                  description: `DTO "${dto.name}" Êú™Ë¢´ÂÆûÁé∞Êò†Â∞ÑÊàñÂ±èÂπïÂÆö‰πâÂºïÁî®`
                });
              }
            });
          }
          break;
      }
      
      if (unused.length > 0) {
        this.unusedElements.set(schemaName, unused);
      }
    }
  }

  /**
   * ÂèëÁé∞Â≠§Á´ãÁöÑÂºïÁî®
   */
  findOrphanedReferences(schemas) {
    console.log('üîç ÂèëÁé∞Â≠§Á´ãÁöÑÂºïÁî®...');
    
    for (const [schemaName, schema] of schemas) {
      const orphaned = [];
      
      // Ê£ÄÊü•ÂºïÁî®ÁöÑÂÖÉÁ¥†ÊòØÂê¶Â≠òÂú®
      const references = this.referenceMap.get(schemaName);
      if (references) {
        references.references.forEach(ref => {
          const [targetSchema, targetId] = ref.target.split(':');
          const targetSchemaData = schemas.get(targetSchema);
          
          if (!targetSchemaData) {
            orphaned.push({
              type: 'MISSING_SCHEMA',
              source: ref.source,
              target: ref.target,
              description: `ÂºïÁî®ÁöÑSchema "${targetSchema}" ‰∏çÂ≠òÂú®`
            });
          } else {
            // Ê£ÄÊü•ÂºïÁî®ÁöÑÂÖÉÁ¥†ÊòØÂê¶Â≠òÂú®
            const elementExists = this.checkElementExists(targetSchemaData, targetId);
            if (!elementExists) {
              orphaned.push({
                type: 'MISSING_ELEMENT',
                source: ref.source,
                target: ref.target,
                description: `ÂºïÁî®ÁöÑÂÖÉÁ¥† "${targetId}" Âú® "${targetSchema}" ‰∏≠‰∏çÂ≠òÂú®`
              });
            }
          }
        });
      }
      
      if (orphaned.length > 0) {
        this.orphanedReferences.set(schemaName, orphaned);
      }
    }
  }

  /**
   * Ê£ÄÊü•ÂÖÉÁ¥†ÊòØÂê¶Â≠òÂú®
   */
  checkElementExists(schemaData, elementId) {
    // Ê†πÊçÆÂÖÉÁ¥†IDÁöÑÂâçÁºÄÂà§Êñ≠Á±ªÂûãÂπ∂Ê£ÄÊü•Â≠òÂú®ÊÄß
    if (elementId.startsWith('term_')) {
      return schemaData.businessTerms?.some(term => term.id === elementId);
    } else if (elementId.startsWith('attr_')) {
      return schemaData.businessAttributes?.some(attr => attr.id === elementId);
    } else if (elementId.startsWith('bc_')) {
      return schemaData.boundedContexts?.some(context => context.id === elementId);
    } else if (elementId.startsWith('entity_')) {
      return schemaData.entities?.some(entity => entity.id === elementId);
    } else if (elementId.startsWith('dto_')) {
      return schemaData.dataTransferObjects?.some(dto => dto.id === elementId);
    }
    
    return false;
  }

  /**
   * ÁîüÊàê‰ΩøÁî®Áä∂ÊÄÅÊä•Âëä
   */
  generateUsageReport() {
    const report = {
      timestamp: new Date().toISOString(),
      summary: {
        totalSchemas: this.referenceMap.size,
        totalReferences: 0,
        unusedElements: 0,
        orphanedReferences: 0
      },
      details: {
        references: Object.fromEntries(this.referenceMap),
        unusedElements: Object.fromEntries(this.unusedElements),
        orphanedReferences: Object.fromEntries(this.orphanedReferences)
      },
      recommendations: []
    };

    // ÁªüËÆ°ÊÄªÊï∞
    for (const [schemaName, references] of this.referenceMap) {
      report.summary.totalReferences += references.references.length;
    }
    
    for (const [schemaName, unused] of this.unusedElements) {
      report.summary.unusedElements += unused.length;
    }
    
    for (const [schemaName, orphaned] of this.orphanedReferences) {
      report.summary.orphanedReferences += orphaned.length;
    }

    // ÁîüÊàêÂª∫ËÆÆ
    if (report.summary.unusedElements > 0) {
      report.recommendations.push('ÂèëÁé∞Êú™‰ΩøÁî®ÁöÑÂÖÉÁ¥†ÔºåÂª∫ËÆÆÊ£ÄÊü•ÊòØÂê¶ÈÅóÊºè‰∫ÜËÆæËÆ°Ê≠•È™§');
    }
    
    if (report.summary.orphanedReferences > 0) {
      report.recommendations.push('ÂèëÁé∞Â≠§Á´ãÁöÑÂºïÁî®ÔºåÂª∫ËÆÆÊ£ÄÊü•ÂºïÁî®ÁöÑÂÖÉÁ¥†ÊòØÂê¶Â≠òÂú®');
    }

    return report;
  }

  /**
   * Ëé∑Âèñ‰ΩøÁî®Áä∂ÊÄÅÊëòË¶Å
   */
  getUsageSummary(schemas) {
    const summary = {
      ubiquitousLanguage: {
        totalTerms: 0,
        usedTerms: 0,
        totalAttributes: 0,
        usedAttributes: 0
      },
      strategicDesign: {
        totalContexts: 0,
        usedContexts: 0
      },
      tacticalDesign: {
        totalEntities: 0,
        usedEntities: 0
      },
      dtoManagement: {
        totalDtos: 0,
        usedDtos: 0
      }
    };

    // ÁªüËÆ°Áªü‰∏ÄËØ≠Ë®Ä
    const ulSchema = schemas.get('ubiquitous-language.schema.json');
    if (ulSchema) {
      if (ulSchema.businessTerms) {
        summary.ubiquitousLanguage.totalTerms = ulSchema.businessTerms.length;
        summary.ubiquitousLanguage.usedTerms = ulSchema.businessTerms.filter(term => 
          term.usageStatus?.isReferencedByStrategic || 
          term.usageStatus?.isReferencedByTactical || 
          term.usageStatus?.isReferencedByDto
        ).length;
      }
      
      if (ulSchema.businessAttributes) {
        summary.ubiquitousLanguage.totalAttributes = ulSchema.businessAttributes.length;
        summary.ubiquitousLanguage.usedAttributes = ulSchema.businessAttributes.filter(attr => 
          attr.usageStatus?.isReferencedByTactical || 
          attr.usageStatus?.isReferencedByDto
        ).length;
      }
    }

    // ÁªüËÆ°ÊàòÁï•ËÆæËÆ°
    const sdSchema = schemas.get('strategic-design.schema.json');
    if (sdSchema) {
      if (sdSchema.boundedContexts) {
        summary.strategicDesign.totalContexts = sdSchema.boundedContexts.length;
        summary.strategicDesign.usedContexts = sdSchema.boundedContexts.filter(context => 
          context.usageStatus?.isReferencedByTactical || 
          context.usageStatus?.isReferencedByDto || 
          context.usageStatus?.isReferencedByImplementation || 
          context.usageStatus?.isReferencedByScreen
        ).length;
      }
    }

    // ÁªüËÆ°ÊàòÊúØËÆæËÆ°
    const tdSchema = schemas.get('tactical-design.schema.json');
    if (tdSchema) {
      if (tdSchema.entities) {
        summary.tacticalDesign.totalEntities = tdSchema.entities.length;
        summary.tacticalDesign.usedEntities = tdSchema.entities.filter(entity => 
          entity.usageStatus?.isReferencedByImplementation
        ).length;
      }
    }

    // ÁªüËÆ°DTOÁÆ°ÁêÜ
    const dtoSchema = schemas.get('data-transfer-objects.schema.json');
    if (dtoSchema) {
      if (dtoSchema.dataTransferObjects) {
        summary.dtoManagement.totalDtos = dtoSchema.dataTransferObjects.length;
        summary.dtoManagement.usedDtos = dtoSchema.dataTransferObjects.filter(dto => 
          dto.usageStatus?.isReferencedByImplementation || 
          dto.usageStatus?.isReferencedByScreen
        ).length;
      }
    }

    return summary;
  }
}

// ‰ΩøÁî®Á§∫‰æã
async function main() {
  const analyzer = new ReferenceAnalyzer();
  
  // Âä†ËΩΩÊâÄÊúâSchema
  const schemas = new Map();
  // ËøôÈáåÂ∫îËØ•Âä†ËΩΩÂÆûÈôÖÁöÑSchemaÊï∞ÊçÆ
  
  // ÂàÜÊûêÂºïÁî®ÂÖ≥Á≥ª
  const report = await analyzer.analyzeReferences(schemas);
  
  // ÂèëÁé∞Êú™‰ΩøÁî®ÁöÑÂÖÉÁ¥†
  analyzer.findUnusedElements(schemas);
  
  // ÂèëÁé∞Â≠§Á´ãÁöÑÂºïÁî®
  analyzer.findOrphanedReferences(schemas);
  
  // Ëé∑Âèñ‰ΩøÁî®Áä∂ÊÄÅÊëòË¶Å
  const summary = analyzer.getUsageSummary(schemas);
  
  console.log('üìä ÂºïÁî®ÂÖ≥Á≥ªÂàÜÊûêÊä•Âëä:');
  console.log(JSON.stringify(report, null, 2));
  
  console.log('üìà ‰ΩøÁî®Áä∂ÊÄÅÊëòË¶Å:');
  console.log(JSON.stringify(summary, null, 2));
}

// Â¶ÇÊûúÁõ¥Êé•ËøêË°åÊ≠§Êñá‰ª∂
if (require.main === module) {
  main();
}

module.exports = ReferenceAnalyzer;
